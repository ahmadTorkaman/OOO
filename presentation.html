<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OZONE - The Mutual Language of Design and Production</title>

  <!-- Google Fonts - Montserrat -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">

  <!-- Component CSS -->
  <link rel="stylesheet" href="./Presentation/VariableProximity/VariableProximity.css">
  <link rel="stylesheet" href="./Presentation/MetaBalls/MetaBalls.css">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Montserrat', sans-serif;
    }

    #root {
      width: 100%;
      height: 100%;
      position: relative;
    }

    /* Slide 1 - Hero */
    .slide-hero {
      width: 100%;
      height: 100vh;
      position: relative;
      background: linear-gradient(135deg, #ffffff 0%, #e8ebf5 50%, #4c62ba 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .metaballs-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      opacity: 0.6;
    }

    .hero-content {
      position: relative;
      z-index: 10;
      text-align: center;
    }

    .ozone-logo {
      font-family: 'Montserrat', sans-serif;
      font-size: 12rem;
      font-weight: 900;
      color: #000000;
      letter-spacing: 0.1em;
      cursor: default;
      user-select: none;
    }

    .ozone-tagline {
      font-family: 'Montserrat', sans-serif;
      font-size: 1.8rem;
      font-weight: 300;
      color: #333333;
      margin-top: 2rem;
      letter-spacing: 0.05em;
    }

    /* Override for VariableProximity */
    .variable-proximity {
      font-family: 'Montserrat', sans-serif !important;
    }

    /* Make MetaBalls container fill parent */
    .metaballs-container {
      width: 100% !important;
      height: 100% !important;
    }

    .metaballs-container canvas {
      width: 100% !important;
      height: 100% !important;
    }

    /* Ball labels */
    .ball-labels {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .ball-label {
      position: absolute;
      font-family: 'Montserrat', sans-serif;
      font-weight: 100;
      color: #000000;
      white-space: nowrap;
      transform: translate(-50%, -50%);
    }

    .ball-label.small {
      font-size: 3rem;
    }

    .ball-label.large {
      font-size: 2.5rem;
      transform: translate(0, -50%);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Import map for ES modules -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/": "https://esm.sh/react@18.2.0/",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "motion/react": "https://esm.sh/motion@11.14.4/react?external=react,react-dom",
        "ogl": "https://esm.sh/ogl@1.0.6"
      }
    }
  </script>

  <!-- Main App - Using type=module for ES imports -->
  <script type="module">
    import React, { useState, useRef, useEffect, useMemo, forwardRef, useCallback, createElement as h } from 'react';
    import { createRoot } from 'react-dom/client';

    // Import from ESM
    import { motion } from 'motion/react';
    import { Renderer, Program, Mesh, Triangle, Vec3 } from 'ogl';

    // ============================================
    // MetaBalls Component
    // ============================================

    function parseHexColor(hex) {
      const c = hex.replace('#', '');
      const r = parseInt(c.substring(0, 2), 16) / 255;
      const g = parseInt(c.substring(2, 4), 16) / 255;
      const b = parseInt(c.substring(4, 6), 16) / 255;
      return [r, g, b];
    }

    function fract(x) {
      return x - Math.floor(x);
    }

    function hash31(p) {
      let r = [p * 0.1031, p * 0.103, p * 0.0973].map(fract);
      const r_yzx = [r[1], r[2], r[0]];
      const dotVal = r[0] * (r_yzx[0] + 33.33) + r[1] * (r_yzx[1] + 33.33) + r[2] * (r_yzx[2] + 33.33);
      for (let i = 0; i < 3; i++) {
        r[i] = fract(r[i] + dotVal);
      }
      return r;
    }

    function hash33(v) {
      let p = [v[0] * 0.1031, v[1] * 0.103, v[2] * 0.0973].map(fract);
      const p_yxz = [p[1], p[0], p[2]];
      const dotVal = p[0] * (p_yxz[0] + 33.33) + p[1] * (p_yxz[1] + 33.33) + p[2] * (p_yxz[2] + 33.33);
      for (let i = 0; i < 3; i++) {
        p[i] = fract(p[i] + dotVal);
      }
      const p_xxy = [p[0], p[0], p[1]];
      const p_yxx = [p[1], p[0], p[0]];
      const p_zyx = [p[2], p[1], p[0]];
      const result = [];
      for (let i = 0; i < 3; i++) {
        result[i] = fract((p_xxy[i] + p_yxx[i]) * p_zyx[i]);
      }
      return result;
    }

    const vertex = `#version 300 es
    precision highp float;
    layout(location = 0) in vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }
    `;

    const fragment = `#version 300 es
    precision highp float;
    uniform vec3 iResolution;
    uniform float iTime;
    uniform vec3 iMouse;
    uniform vec3 iColor;
    uniform vec3 iCursorColor;
    uniform float iAnimationSize;
    uniform int iBallCount;
    uniform float iCursorBallSize;
    uniform vec3 iMetaBalls[50];
    uniform float iClumpFactor;
    uniform bool enableTransparency;
    out vec4 outColor;

    float getMetaBallValue(vec2 c, float r, vec2 p) {
      vec2 d = p - c;
      float dist2 = dot(d, d);
      return (r * r) / dist2;
    }

    void main() {
      vec2 fc = gl_FragCoord.xy;
      float scale = iAnimationSize / iResolution.y;
      vec2 coord = (fc - iResolution.xy * 0.5) * scale;
      vec2 mouseW = (iMouse.xy - iResolution.xy * 0.5) * scale;
      float m1 = 0.0;
      for (int i = 0; i < 50; i++) {
        if (i >= iBallCount) break;
        m1 += getMetaBallValue(iMetaBalls[i].xy, iMetaBalls[i].z, coord);
      }
      float m2 = getMetaBallValue(mouseW, iCursorBallSize, coord);
      float total = m1 + m2;
      float f = smoothstep(-1.0, 1.0, (total - 1.3) / min(1.0, fwidth(total)));
      vec3 cFinal = vec3(0.0);
      if (total > 0.0) {
        float alpha1 = m1 / total;
        float alpha2 = m2 / total;
        cFinal = iColor * alpha1 + iCursorColor * alpha2;
      }
      outColor = vec4(cFinal * f, enableTransparency ? f : 1.0);
    }
    `;

    function MetaBalls({
      className = '',
      color = '#4c62ba',
      speed = 0.2,
      enableMouseInteraction = true,
      hoverSmoothness = 0.05,
      animationSize = 40,
      ballCount = 3,
      clumpFactor = 1.2,
      cursorBallSize = 2,
      cursorBallColor = '#6a7fc1',
      enableTransparency = true,
      alignMode = false,
      onBallPositionsUpdate = null
    }) {
      const containerRef = useRef(null);

      useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        const dpr = 1;
        const renderer = new Renderer({ dpr, alpha: true, premultipliedAlpha: false });
        const gl = renderer.gl;
        gl.clearColor(0, 0, 0, 0);
        container.appendChild(gl.canvas);

        const geometry = new Triangle(gl);
        const [r1, g1, b1] = parseHexColor(color);
        const [r2, g2, b2] = parseHexColor(cursorBallColor);

        const metaBallsUniform = [];
        for (let i = 0; i < 50; i++) {
          metaBallsUniform.push(new Vec3(0, 0, 0));
        }

        const program = new Program(gl, {
          vertex,
          fragment,
          uniforms: {
            iTime: { value: 0 },
            iResolution: { value: new Vec3(0, 0, 0) },
            iMouse: { value: new Vec3(0, 0, 0) },
            iColor: { value: new Vec3(r1, g1, b1) },
            iCursorColor: { value: new Vec3(r2, g2, b2) },
            iAnimationSize: { value: animationSize },
            iBallCount: { value: ballCount },
            iCursorBallSize: { value: cursorBallSize },
            iMetaBalls: { value: metaBallsUniform },
            iClumpFactor: { value: clumpFactor },
            enableTransparency: { value: enableTransparency }
          }
        });

        const mesh = new Mesh(gl, { geometry, program });

        const effectiveBallCount = Math.min(ballCount, 50);
        const ballParams = [];
        for (let i = 0; i < effectiveBallCount; i++) {
          const idx = i + 1;
          const h1 = hash31(idx);
          const st = h1[0] * (2 * Math.PI);
          const dtFactor = 0.1 * Math.PI + h1[1] * (0.4 * Math.PI - 0.1 * Math.PI);
          const baseScale = 5.0 + h1[1] * (10.0 - 5.0);
          const h2 = hash33(h1);
          const toggle = Math.floor(h2[0] * 2.0);
          const radiusVal = 2.5; // Same size for all balls
          ballParams.push({ st, dtFactor, baseScale, toggle, radius: radiusVal });
        }

        const mouseBallPos = { x: 0, y: 0 };
        let pointerInside = false;
        let pointerX = 0;
        let pointerY = 0;

        function resize() {
          if (!container) return;
          const width = container.clientWidth;
          const height = container.clientHeight;
          renderer.setSize(width * dpr, height * dpr);
          gl.canvas.style.width = width + 'px';
          gl.canvas.style.height = height + 'px';
          program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, 0);
        }
        window.addEventListener('resize', resize);
        resize();

        function onPointerMove(e) {
          if (!enableMouseInteraction) return;
          const rect = container.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          pointerX = (px / rect.width) * gl.canvas.width;
          pointerY = (1 - py / rect.height) * gl.canvas.height;
        }
        function onPointerEnter() {
          if (!enableMouseInteraction) return;
          pointerInside = true;
        }
        function onPointerLeave() {
          if (!enableMouseInteraction) return;
          pointerInside = false;
        }
        container.addEventListener('pointermove', onPointerMove);
        container.addEventListener('pointerenter', onPointerEnter);
        container.addEventListener('pointerleave', onPointerLeave);

        const startTime = performance.now();
        let animationFrameId;
        function update(t) {
          animationFrameId = requestAnimationFrame(update);
          const elapsed = (t - startTime) * 0.001;
          program.uniforms.iTime.value = elapsed;

          if (alignMode) {
            // Aligned mode: balls in vertical column with subtle breathing
            const centerX = 0;
            const spacing = 25; // Vertical spacing between balls

            for (let i = 0; i < 3; i++) {
              // Vertical positions: top, middle, bottom
              const baseY = (i - 1) * spacing; // -spacing, 0, spacing

              // Subtle breathing motion
              const breathX = Math.sin(elapsed * 0.5 + i * 0.3) * 0.8;
              const breathY = Math.cos(elapsed * 0.6 + i * 0.4) * 0.6;

              metaBallsUniform[i].set(centerX + breathX, baseY + breathY, 2.5);
            }

            // Hide cursor ball
            program.uniforms.iMouse.value.set(10000, 10000, 0);
          } else {
            // Flowing animation for all balls
            for (let i = 0; i < effectiveBallCount; i++) {
              const p = ballParams[i];
              const dt = elapsed * speed * p.dtFactor;
              const th = p.st + dt;
              const x = Math.cos(th);
              const y = Math.sin(th + dt * p.toggle);
              const posX = x * p.baseScale * clumpFactor;
              const posY = y * p.baseScale * clumpFactor;
              metaBallsUniform[i].set(posX, posY, p.radius);
            }

            let targetX, targetY;
            if (pointerInside) {
              targetX = pointerX;
              targetY = pointerY;
            } else {
              const cx = gl.canvas.width * 0.5;
              const cy = gl.canvas.height * 0.5;
              const rx = gl.canvas.width * 0.15;
              const ry = gl.canvas.height * 0.15;
              targetX = cx + Math.cos(elapsed * speed) * rx;
              targetY = cy + Math.sin(elapsed * speed) * ry;
            }
            mouseBallPos.x += (targetX - mouseBallPos.x) * hoverSmoothness;
            mouseBallPos.y += (targetY - mouseBallPos.y) * hoverSmoothness;
            program.uniforms.iMouse.value.set(mouseBallPos.x, mouseBallPos.y, 0);
          }

          // Report ball positions for labels
          if (onBallPositionsUpdate && container) {
            const containerRect = container.getBoundingClientRect();
            const scale = animationSize / gl.canvas.height;
            const positions = [];
            for (let i = 0; i < Math.min(3, effectiveBallCount); i++) {
              const ball = metaBallsUniform[i];
              // Convert from shader space to screen space
              const screenX = (ball.x / scale) + containerRect.width / 2;
              const screenY = (-ball.y / scale) + containerRect.height / 2;
              positions.push({ x: screenX, y: screenY });
            }
            onBallPositionsUpdate(positions);
          }

          renderer.render({ scene: mesh });
        }
        animationFrameId = requestAnimationFrame(update);

        return () => {
          cancelAnimationFrame(animationFrameId);
          window.removeEventListener('resize', resize);
          container.removeEventListener('pointermove', onPointerMove);
          container.removeEventListener('pointerenter', onPointerEnter);
          container.removeEventListener('pointerleave', onPointerLeave);
          if (gl.canvas && container.contains(gl.canvas)) {
            container.removeChild(gl.canvas);
          }
          gl.getExtension('WEBGL_lose_context')?.loseContext();
        };
      }, [color, cursorBallColor, speed, enableMouseInteraction, hoverSmoothness, animationSize, ballCount, clumpFactor, cursorBallSize, enableTransparency, alignMode, onBallPositionsUpdate]);

      return h('div', { ref: containerRef, className: `metaballs-container ${className}` });
    }

    // ============================================
    // VariableProximity Component
    // ============================================

    function useAnimationFrame(callback) {
      useEffect(() => {
        let frameId;
        const loop = () => {
          callback();
          frameId = requestAnimationFrame(loop);
        };
        frameId = requestAnimationFrame(loop);
        return () => cancelAnimationFrame(frameId);
      }, [callback]);
    }

    function useMousePositionRef(containerRef) {
      const positionRef = useRef({ x: 0, y: 0 });

      useEffect(() => {
        const updatePosition = (x, y) => {
          if (containerRef?.current) {
            const rect = containerRef.current.getBoundingClientRect();
            positionRef.current = { x: x - rect.left, y: y - rect.top };
          } else {
            positionRef.current = { x, y };
          }
        };

        const handleMouseMove = ev => updatePosition(ev.clientX, ev.clientY);
        const handleTouchMove = ev => {
          const touch = ev.touches[0];
          updatePosition(touch.clientX, touch.clientY);
        };

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('touchmove', handleTouchMove);
        return () => {
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('touchmove', handleTouchMove);
        };
      }, [containerRef]);

      return positionRef;
    }

    const VariableProximity = forwardRef((props, ref) => {
      const {
        label,
        fromFontVariationSettings = "'wght' 400",
        toFontVariationSettings = "'wght' 900",
        containerRef,
        radius = 150,
        falloff = 'linear',
        className = '',
        onClick,
        style,
        ...restProps
      } = props;

      const letterRefs = useRef([]);
      const interpolatedSettingsRef = useRef([]);
      const mousePositionRef = useMousePositionRef(containerRef);
      const lastPositionRef = useRef({ x: null, y: null });

      const parsedSettings = useMemo(() => {
        const parseSettings = settingsStr =>
          new Map(
            settingsStr
              .split(',')
              .map(s => s.trim())
              .map(s => {
                const [name, value] = s.split(' ');
                return [name.replace(/['"]/g, ''), parseFloat(value)];
              })
          );

        const fromSettings = parseSettings(fromFontVariationSettings);
        const toSettings = parseSettings(toFontVariationSettings);

        return Array.from(fromSettings.entries()).map(([axis, fromValue]) => ({
          axis,
          fromValue,
          toValue: toSettings.get(axis) ?? fromValue
        }));
      }, [fromFontVariationSettings, toFontVariationSettings]);

      const calculateDistance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

      const calculateFalloff = distance => {
        const norm = Math.min(Math.max(1 - distance / radius, 0), 1);
        switch (falloff) {
          case 'exponential':
            return norm ** 2;
          case 'gaussian':
            return Math.exp(-((distance / (radius / 2)) ** 2) / 2);
          case 'linear':
          default:
            return norm;
        }
      };

      useAnimationFrame(() => {
        if (!containerRef?.current) return;
        const containerRect = containerRef.current.getBoundingClientRect();
        const { x, y } = mousePositionRef.current;
        if (lastPositionRef.current.x === x && lastPositionRef.current.y === y) {
          return;
        }
        lastPositionRef.current = { x, y };

        letterRefs.current.forEach((letterRef, index) => {
          if (!letterRef) return;

          const rect = letterRef.getBoundingClientRect();
          const letterCenterX = rect.left + rect.width / 2 - containerRect.left;
          const letterCenterY = rect.top + rect.height / 2 - containerRect.top;

          const distance = calculateDistance(
            mousePositionRef.current.x,
            mousePositionRef.current.y,
            letterCenterX,
            letterCenterY
          );

          if (distance >= radius) {
            letterRef.style.fontVariationSettings = fromFontVariationSettings;
            return;
          }

          const falloffValue = calculateFalloff(distance);
          const newSettings = parsedSettings
            .map(({ axis, fromValue, toValue }) => {
              const interpolatedValue = fromValue + (toValue - fromValue) * falloffValue;
              return `'${axis}' ${interpolatedValue}`;
            })
            .join(', ');

          interpolatedSettingsRef.current[index] = newSettings;
          letterRef.style.fontVariationSettings = newSettings;
        });
      });

      const words = label.split(' ');
      let letterIndex = 0;

      return h(
        'span',
        {
          ref,
          className: `${className} variable-proximity`,
          onClick,
          style: { display: 'inline', ...style },
          ...restProps
        },
        words.map((word, wordIndex) =>
          h(
            'span',
            { key: wordIndex, style: { display: 'inline-block', whiteSpace: 'nowrap' } },
            word.split('').map(letter => {
              const currentLetterIndex = letterIndex++;
              return h(
                motion.span,
                {
                  key: currentLetterIndex,
                  ref: el => {
                    letterRefs.current[currentLetterIndex] = el;
                  },
                  style: {
                    display: 'inline-block',
                    fontVariationSettings: interpolatedSettingsRef.current[currentLetterIndex]
                  },
                  'aria-hidden': true
                },
                letter
              );
            }),
            wordIndex < words.length - 1 && h('span', { style: { display: 'inline-block' } }, '\u00A0')
          )
        ),
        h('span', { className: 'sr-only' }, label)
      );
    });

    // ============================================
    // Main App
    // ============================================

    function App() {
      const containerRef = useRef(null);
      const [clickState, setClickState] = useState(0); // 0: initial, 1: first click, 2: second click
      const [ballPositions, setBallPositions] = useState([]);

      const handleClick = () => {
        if (clickState < 2) {
          setClickState(prev => prev + 1);
        }
      };

      const handleBallPositionsUpdate = useCallback((positions) => {
        setBallPositions(positions);
      }, []);

      // Labels for each state
      const getLabels = () => {
        if (clickState === 0) return null;
        if (clickState === 1) return ['O', 'O', 'O'];
        return ['One System', 'One Tool', 'One Design'];
      };

      const labels = getLabels();

      return h(
        'div',
        {
          className: 'slide-hero',
          ref: containerRef,
          onClick: handleClick,
          style: { cursor: clickState < 2 ? 'pointer' : 'default' }
        },
        h(
          'div',
          { className: 'metaballs-background' },
          h(MetaBalls, {
            color: '#4c62ba',
            cursorBallColor: '#6a7fc1',
            cursorBallSize: 2,
            ballCount: 3,
            animationSize: 30,
            enableMouseInteraction: clickState < 2,
            enableTransparency: true,
            hoverSmoothness: 0.05,
            clumpFactor: 0.8,
            speed: 0.2,
            alignMode: clickState === 2,
            onBallPositionsUpdate: handleBallPositionsUpdate
          }),
          // Ball labels
          labels && h(
            'div',
            { className: 'ball-labels' },
            labels.map((label, i) =>
              ballPositions[i] && h(
                motion.div,
                {
                  key: `${clickState}-${i}`,
                  className: `ball-label ${clickState === 1 ? 'small' : 'large'}`,
                  initial: {
                    opacity: 1,
                    scale: 1,
                    left: `${ballPositions[i].x}px`,
                    top: `${ballPositions[i].y}px`
                  },
                  animate: {
                    opacity: 1,
                    scale: 1,
                    left: clickState === 2 ? `${ballPositions[i].x + 120}px` : `${ballPositions[i].x}px`,
                    top: `${ballPositions[i].y}px`
                  },
                  transition: { duration: 0.8, ease: [0.4, 0, 0.2, 1] }
                },
                label
              )
            )
          )
        ),
        h(
          motion.div,
          {
            className: 'hero-content',
            animate: {
              opacity: clickState === 0 ? 1 : 0,
              scale: clickState === 0 ? 1 : 0.8
            },
            transition: { duration: 0.6, ease: 'easeOut' },
            style: { pointerEvents: clickState === 0 ? 'auto' : 'none' }
          },
          h(
            'div',
            { className: 'ozone-logo' },
            h(VariableProximity, {
              label: 'OZONE',
              fromFontVariationSettings: "'wght' 400",
              toFontVariationSettings: "'wght' 900",
              containerRef: containerRef,
              radius: 200,
              falloff: 'exponential'
            })
          ),
          h('div', { className: 'ozone-tagline' }, 'The Mutual Language of Design and Production')
        )
      );
    }

    // Render
    const root = createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>
