<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OZONE - The Mutual Language of Design and Production</title>

  <!-- Google Fonts - Montserrat -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">

  <!-- Component CSS -->
  <link rel="stylesheet" href="./Presentation/VariableProximity/VariableProximity.css">
  <link rel="stylesheet" href="./Presentation/MetaBalls/MetaBalls.css">
  <link rel="stylesheet" href="./Presentation/TrueFocus/TrueFocus.css">

  <!-- IRANYekan Persian Font -->
  <link rel="stylesheet" href="./Presentation/assets/css/fontiran.css">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Montserrat', sans-serif;
    }

    #root {
      width: 100%;
      height: 100%;
      position: relative;
    }

    /* Slide 1 - Hero */
    .slide-hero {
      width: 100%;
      height: 100vh;
      position: relative;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(232, 235, 245, 0.4) 50%, rgba(76, 98, 186, 0.5) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .hero-content {
      position: relative;
      z-index: 10;
      text-align: center;
    }

    .ozone-logo {
      font-family: 'Montserrat', sans-serif;
      font-size: 12rem;
      font-weight: 900;
      color: #000000;
      letter-spacing: 0.1em;
      cursor: default;
      user-select: none;
    }

    .ozone-tagline {
      font-family: 'Montserrat', sans-serif;
      font-size: 1.8rem;
      font-weight: 300;
      color: #333333;
      margin-top: 2rem;
      letter-spacing: 0.05em;
    }

    /* Override for VariableProximity */
    .variable-proximity {
      font-family: 'Montserrat', sans-serif !important;
    }

    /* Make MetaBalls container fill parent */
    .metaballs-container {
      width: 100% !important;
      height: 100% !important;
    }

    .metaballs-container canvas {
      width: 100% !important;
      height: 100% !important;
    }

    /* Slide Navigation System */
    .presentation-container {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    /* Global MetaBalls Background */
    .global-metaballs-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.6;
      pointer-events: none;
    }

    .slide {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  visibility 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  background 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .slide.active {
      opacity: 1;
      visibility: visible;
    }

    /* Navigation Indicators */
    .slide-indicators {
      position: fixed;
      right: 2rem;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(76, 98, 186, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }

    .indicator.active {
      background: #4c62ba;
      border-color: #4c62ba;
      box-shadow: 0 0 10px rgba(76, 98, 186, 0.5);
    }

    .indicator:hover {
      background: rgba(76, 98, 186, 0.6);
      transform: scale(1.2);
    }

    /* Slide 2 - Philosophy */
    .slide-philosophy {
      width: 100%;
      height: 100vh;
      position: relative;
      background: linear-gradient(135deg, rgba(248, 249, 252, 0.4) 0%, rgba(232, 235, 245, 0.5) 50%, rgba(212, 217, 239, 0.6) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    /* Slide 3 - One System Detail */
    .slide-one-system {
      width: 100%;
      height: 100vh;
      position: relative;
      background: linear-gradient(135deg, rgba(248, 249, 252, 0.4) 0%, rgba(232, 235, 245, 0.5) 50%, rgba(212, 217, 239, 0.6) 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow: hidden;
      padding: 2rem;
      padding-top: 3rem;
      transition: padding 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .slide-one-system.fullscreen {
      padding: 0;
      padding-top: 0;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 30, 0.98) 100%);
    }

    .one-system-header {
      position: relative;
      z-index: 10;
      text-align: center;
      margin-bottom: 2rem;
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  margin 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  height 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      height: auto;
      overflow: hidden;
    }

    .slide-one-system.fullscreen .one-system-header {
      opacity: 0;
      transform: translateY(-100px);
      margin-bottom: 0;
      height: 0;
      pointer-events: none;
    }

    .one-system-content {
      position: relative;
      z-index: 10;
      text-align: center;
      max-width: 95%;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex: 1;
      transition: max-width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .slide-one-system.fullscreen .one-system-content {
      max-width: 100%;
    }

    .scroll-indicator {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      opacity: 1;
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
    }

    .slide-one-system.fullscreen .scroll-indicator {
      opacity: 0;
    }

    .scroll-indicator-text {
      font-family: 'Montserrat', sans-serif;
      font-size: 0.9rem;
      font-weight: 400;
      color: #4c62ba;
      opacity: 0.8;
    }

    .scroll-indicator-icon {
      width: 24px;
      height: 36px;
      border: 2px solid #4c62ba;
      border-radius: 12px;
      position: relative;
      opacity: 0.6;
    }

    .scroll-indicator-icon::before {
      content: '';
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 8px;
      background: #4c62ba;
      border-radius: 2px;
      animation: scrollAnimation 2s ease-in-out infinite;
    }

    @keyframes scrollAnimation {
      0%, 100% {
        opacity: 0;
        transform: translateX(-50%) translateY(0);
      }
      50% {
        opacity: 1;
        transform: translateX(-50%) translateY(12px);
      }
    }

    .one-system-title {
      font-family: 'Montserrat', sans-serif;
      font-size: 3rem;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 0.5rem;
      letter-spacing: 0.05em;
    }

    .one-system-subtitle {
      font-family: iranyekan, sans-serif;
      font-size: 1.5rem;
      font-weight: 400;
      color: #555;
      direction: rtl;
      margin-bottom: 0;
    }

    .system-features {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 2rem;
      margin-top: 3rem;
    }

    .feature-card {
      background: rgba(255, 255, 255, 0.8);
      padding: 2rem;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      cursor: pointer;
    }

    .feature-card:hover {
      transform: translateY(-8px);
      box-shadow: 0 8px 30px rgba(76, 98, 186, 0.3);
    }

    .feature-card h3 {
      font-family: 'Montserrat', sans-serif;
      font-size: 1.5rem;
      font-weight: 600;
      color: #4c62ba;
      margin-bottom: 1rem;
    }

    .feature-card p {
      font-family: 'Montserrat', sans-serif;
      font-size: 1rem;
      font-weight: 400;
      color: #666;
      line-height: 1.6;
    }

    .back-hint {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Montserrat', sans-serif;
      font-size: 1rem;
      font-weight: 300;
      color: #4c62ba;
      opacity: 0.6;
      pointer-events: none;
    }

    /* macOS Window Styles */
    .macos-window {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
                  0 0 1px rgba(0, 0, 0, 0.2);
      overflow: hidden;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      position: relative;
      width: 90vw;
      max-width: 1400px;
      height: 75vh;
      max-height: 800px;
      transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  box-shadow 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  border-radius 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .macos-window.fullscreen {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      border-radius: 0;
      box-shadow: none;
      background: rgba(255, 255, 255, 1);
    }

    .macos-window.fullscreen .macos-titlebar {
      opacity: 0;
      height: 0;
      overflow: hidden;
      border-bottom: none;
      transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  height 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .macos-window.fullscreen .macos-window-content {
      height: 100%;
    }

    .macos-titlebar {
      background: linear-gradient(to bottom,
                  rgba(232, 232, 232, 0.98) 0%,
                  rgba(220, 220, 220, 0.98) 100%);
      height: 40px;
      display: flex;
      align-items: center;
      padding: 0 1rem;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      position: relative;
      transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  height 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                  border-bottom 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .macos-traffic-lights {
      display: flex;
      gap: 8px;
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
    }

    .macos-traffic-light {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 0.5px solid rgba(0, 0, 0, 0.15);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .macos-traffic-light::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .macos-traffic-light:hover::before {
      opacity: 1;
    }

    .macos-traffic-light.close {
      background: linear-gradient(135deg, #FF5F57 0%, #FF5A52 100%);
    }

    .macos-traffic-light.close:hover::before {
      content: '×';
      font-size: 10px;
      font-weight: bold;
      color: rgba(0, 0, 0, 0.6);
    }

    .macos-traffic-light.minimize {
      background: linear-gradient(135deg, #FFBD2E 0%, #FFB923 100%);
    }

    .macos-traffic-light.minimize:hover::before {
      content: '−';
      font-size: 10px;
      font-weight: bold;
      color: rgba(0, 0, 0, 0.6);
    }

    .macos-traffic-light.maximize {
      background: linear-gradient(135deg, #28CA42 0%, #27C93F 100%);
    }

    .macos-traffic-light.maximize:hover::before {
      content: '+';
      font-size: 10px;
      font-weight: bold;
      color: rgba(0, 0, 0, 0.6);
    }

    .macos-window-title {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Montserrat', sans-serif;
      font-size: 13px;
      font-weight: 500;
      color: rgba(0, 0, 0, 0.85);
      letter-spacing: 0.01em;
    }

    .macos-window-content {
      padding: 0;
      height: calc(100% - 40px);
      background: rgba(255, 255, 255, 0.98);
      overflow: hidden;
      position: relative;
    }

    .macos-window-content iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
    }

    /* Custom scrollbar for macOS window */
    .macos-window-content::-webkit-scrollbar {
      width: 8px;
    }

    .macos-window-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .macos-window-content::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }

    .macos-window-content::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.3);
    }

    .philosophy-content {
      position: relative;
      z-index: 10;
      text-align: center;
      max-width: 90%;
    }

    .philosophy-title {
      font-family: 'Montserrat', sans-serif;
      font-size: 1.2rem;
      font-weight: 300;
      color: #666;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      margin-bottom: 4rem;
      opacity: 0.7;
    }

    .philosophy-focus {
      font-size: 5rem;
      color: #2c3e50;
    }

    /* Override TrueFocus styles for this slide */
    .slide-philosophy .focus-container {
      flex-direction: column;
      gap: 3rem;
    }

    .slide-philosophy .focus-word {
      font-family: 'Montserrat', sans-serif;
      font-size: 4.5rem;
      font-weight: 400;
      color: #2c3e50;
      transition: filter 0.6s ease, color 0.6s ease;
      display: flex;
      align-items: center;
      gap: 2rem;
      justify-content: center;
      position: relative;
    }

    .slide-philosophy .focus-word::before {
      content: '';
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 2px;
      height: 80%;
      background: linear-gradient(to bottom, transparent, rgba(76, 98, 186, 0.3), transparent);
    }

    .slide-philosophy .focus-word .english {
      font-family: 'Montserrat', sans-serif;
      font-weight: 400;
      order: 2;
      text-align: left;
      flex: 1;
    }

    .slide-philosophy .focus-word .persian {
      font-family: iranyekan, sans-serif;
      font-weight: 400;
      direction: rtl;
      order: 1;
      text-align: right;
      flex: 1;
    }

    .slide-philosophy .focus-word em {
      font-style: italic;
      font-weight: 400;
    }

    .slide-philosophy .corner {
      border-color: #4c62ba;
      filter: drop-shadow(0px 0px 8px rgba(76, 98, 186, 0.6));
    }

    .slide-philosophy .focus-word {
      cursor: pointer;
      user-select: none;
    }

    .slide-philosophy .focus-word:first-child:hover {
      transform: scale(1.05);
      transition: transform 0.3s ease;
    }

    /* Responsive text */
    @media (max-width: 1200px) {
      .ozone-logo {
        font-size: 8rem;
      }
      .philosophy-focus {
        font-size: 3rem;
      }
      .slide-philosophy .focus-word {
        font-size: 3rem;
        gap: 1.5rem;
      }
    }

    @media (max-width: 768px) {
      .ozone-logo {
        font-size: 5rem;
      }
      .ozone-tagline {
        font-size: 1.2rem;
      }
      .philosophy-focus {
        font-size: 2rem;
      }
      .slide-philosophy .focus-word {
        font-size: 2rem;
        gap: 1rem;
        flex-direction: column;
      }
      .slide-philosophy .focus-container {
        gap: 2rem;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Import map for ES modules -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/": "https://esm.sh/react@18.2.0/",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "motion/react": "https://esm.sh/motion@11.14.4/react?external=react,react-dom",
        "ogl": "https://esm.sh/ogl@1.0.6",
        "matter-js": "https://esm.sh/matter-js@0.19.0"
      }
    }
  </script>

  <!-- Main App - Using type=module for ES imports -->
  <script type="module">
    import React, { useState, useRef, useEffect, useMemo, forwardRef, createElement as h } from 'react';
    import { createRoot } from 'react-dom/client';

    // Import from ESM
    import { motion } from 'motion/react';
    import { Renderer, Program, Mesh, Triangle, Vec3 } from 'ogl';
    import Matter from 'matter-js';

    // ============================================
    // MetaBalls Component
    // ============================================

    function parseHexColor(hex) {
      const c = hex.replace('#', '');
      const r = parseInt(c.substring(0, 2), 16) / 255;
      const g = parseInt(c.substring(2, 4), 16) / 255;
      const b = parseInt(c.substring(4, 6), 16) / 255;
      return [r, g, b];
    }

    function fract(x) {
      return x - Math.floor(x);
    }

    function hash31(p) {
      let r = [p * 0.1031, p * 0.103, p * 0.0973].map(fract);
      const r_yzx = [r[1], r[2], r[0]];
      const dotVal = r[0] * (r_yzx[0] + 33.33) + r[1] * (r_yzx[1] + 33.33) + r[2] * (r_yzx[2] + 33.33);
      for (let i = 0; i < 3; i++) {
        r[i] = fract(r[i] + dotVal);
      }
      return r;
    }

    function hash33(v) {
      let p = [v[0] * 0.1031, v[1] * 0.103, v[2] * 0.0973].map(fract);
      const p_yxz = [p[1], p[0], p[2]];
      const dotVal = p[0] * (p_yxz[0] + 33.33) + p[1] * (p_yxz[1] + 33.33) + p[2] * (p_yxz[2] + 33.33);
      for (let i = 0; i < 3; i++) {
        p[i] = fract(p[i] + dotVal);
      }
      const p_xxy = [p[0], p[0], p[1]];
      const p_yxx = [p[1], p[0], p[0]];
      const p_zyx = [p[2], p[1], p[0]];
      const result = [];
      for (let i = 0; i < 3; i++) {
        result[i] = fract((p_xxy[i] + p_yxx[i]) * p_zyx[i]);
      }
      return result;
    }

    const vertex = `#version 300 es
    precision highp float;
    layout(location = 0) in vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }
    `;

    const fragment = `#version 300 es
    precision highp float;
    uniform vec3 iResolution;
    uniform float iTime;
    uniform vec3 iMouse;
    uniform vec3 iColor;
    uniform vec3 iCursorColor;
    uniform float iAnimationSize;
    uniform int iBallCount;
    uniform float iCursorBallSize;
    uniform vec3 iMetaBalls[50];
    uniform float iClumpFactor;
    uniform bool enableTransparency;
    out vec4 outColor;

    float getMetaBallValue(vec2 c, float r, vec2 p) {
      vec2 d = p - c;
      float dist2 = dot(d, d);
      return (r * r) / dist2;
    }

    void main() {
      vec2 fc = gl_FragCoord.xy;
      float scale = iAnimationSize / iResolution.y;
      vec2 coord = (fc - iResolution.xy * 0.5) * scale;
      vec2 mouseW = (iMouse.xy - iResolution.xy * 0.5) * scale;
      float m1 = 0.0;
      for (int i = 0; i < 50; i++) {
        if (i >= iBallCount) break;
        m1 += getMetaBallValue(iMetaBalls[i].xy, iMetaBalls[i].z, coord);
      }
      float m2 = getMetaBallValue(mouseW, iCursorBallSize, coord);
      float total = m1 + m2;
      float f = smoothstep(-1.0, 1.0, (total - 1.3) / min(1.0, fwidth(total)));
      vec3 cFinal = vec3(0.0);
      if (total > 0.0) {
        float alpha1 = m1 / total;
        float alpha2 = m2 / total;
        cFinal = iColor * alpha1 + iCursorColor * alpha2;
      }
      outColor = vec4(cFinal * f, enableTransparency ? f : 1.0);
    }
    `;

    function MetaBalls({
      className = '',
      color = '#4c62ba',
      speed = 0.2,
      enableMouseInteraction = true,
      hoverSmoothness = 0.05,
      animationSize = 40,
      ballCount = 12,
      clumpFactor = 1.2,
      cursorBallSize = 2,
      cursorBallColor = '#6a7fc1',
      enableTransparency = true
    }) {
      const containerRef = useRef(null);

      useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        const dpr = 1;
        const renderer = new Renderer({ dpr, alpha: true, premultipliedAlpha: false });
        const gl = renderer.gl;
        gl.clearColor(0, 0, 0, 0);
        container.appendChild(gl.canvas);

        const geometry = new Triangle(gl);
        const [r1, g1, b1] = parseHexColor(color);
        const [r2, g2, b2] = parseHexColor(cursorBallColor);

        const metaBallsUniform = [];
        for (let i = 0; i < 50; i++) {
          metaBallsUniform.push(new Vec3(0, 0, 0));
        }

        const program = new Program(gl, {
          vertex,
          fragment,
          uniforms: {
            iTime: { value: 0 },
            iResolution: { value: new Vec3(0, 0, 0) },
            iMouse: { value: new Vec3(0, 0, 0) },
            iColor: { value: new Vec3(r1, g1, b1) },
            iCursorColor: { value: new Vec3(r2, g2, b2) },
            iAnimationSize: { value: animationSize },
            iBallCount: { value: ballCount },
            iCursorBallSize: { value: cursorBallSize },
            iMetaBalls: { value: metaBallsUniform },
            iClumpFactor: { value: clumpFactor },
            enableTransparency: { value: enableTransparency }
          }
        });

        const mesh = new Mesh(gl, { geometry, program });

        const effectiveBallCount = Math.min(ballCount, 50);
        const ballParams = [];
        for (let i = 0; i < effectiveBallCount; i++) {
          const idx = i + 1;
          const h1 = hash31(idx);
          const st = h1[0] * (2 * Math.PI);
          const dtFactor = 0.1 * Math.PI + h1[1] * (0.4 * Math.PI - 0.1 * Math.PI);
          const baseScale = 5.0 + h1[1] * (10.0 - 5.0);
          const h2 = hash33(h1);
          const toggle = Math.floor(h2[0] * 2.0);
          const radiusVal = 0.3 + h2[2] * (1.5 - 0.3); // Variable sizes: small minimum, less thick maximum
          ballParams.push({ st, dtFactor, baseScale, toggle, radius: radiusVal });
        }

        const mouseBallPos = { x: 0, y: 0 };
        let pointerInside = false;
        let pointerX = 0;
        let pointerY = 0;

        function resize() {
          if (!container) return;
          const width = container.clientWidth;
          const height = container.clientHeight;
          renderer.setSize(width * dpr, height * dpr);
          gl.canvas.style.width = width + 'px';
          gl.canvas.style.height = height + 'px';
          program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, 0);
        }
        window.addEventListener('resize', resize);
        resize();

        function onPointerMove(e) {
          if (!enableMouseInteraction) return;
          const rect = container.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          pointerX = (px / rect.width) * gl.canvas.width;
          pointerY = (1 - py / rect.height) * gl.canvas.height;
        }
        function onPointerEnter() {
          if (!enableMouseInteraction) return;
          pointerInside = true;
        }
        function onPointerLeave() {
          if (!enableMouseInteraction) return;
          pointerInside = false;
        }
        container.addEventListener('pointermove', onPointerMove);
        container.addEventListener('pointerenter', onPointerEnter);
        container.addEventListener('pointerleave', onPointerLeave);

        const startTime = performance.now();
        let animationFrameId;
        function update(t) {
          animationFrameId = requestAnimationFrame(update);
          const elapsed = (t - startTime) * 0.001;
          program.uniforms.iTime.value = elapsed;

          // Flowing animation for all balls
          for (let i = 0; i < effectiveBallCount; i++) {
            const p = ballParams[i];
            const dt = elapsed * speed * p.dtFactor;
            const th = p.st + dt;
            const x = Math.cos(th);
            const y = Math.sin(th + dt * p.toggle);
            const posX = x * p.baseScale * clumpFactor;
            const posY = y * p.baseScale * clumpFactor;
            metaBallsUniform[i].set(posX, posY, p.radius);
          }

          let targetX, targetY;
          if (pointerInside) {
            targetX = pointerX;
            targetY = pointerY;
          } else {
            const cx = gl.canvas.width * 0.5;
            const cy = gl.canvas.height * 0.5;
            const rx = gl.canvas.width * 0.15;
            const ry = gl.canvas.height * 0.15;
            targetX = cx + Math.cos(elapsed * speed) * rx;
            targetY = cy + Math.sin(elapsed * speed) * ry;
          }
          mouseBallPos.x += (targetX - mouseBallPos.x) * hoverSmoothness;
          mouseBallPos.y += (targetY - mouseBallPos.y) * hoverSmoothness;
          program.uniforms.iMouse.value.set(mouseBallPos.x, mouseBallPos.y, 0);

          renderer.render({ scene: mesh });
        }
        animationFrameId = requestAnimationFrame(update);

        return () => {
          cancelAnimationFrame(animationFrameId);
          window.removeEventListener('resize', resize);
          container.removeEventListener('pointermove', onPointerMove);
          container.removeEventListener('pointerenter', onPointerEnter);
          container.removeEventListener('pointerleave', onPointerLeave);
          if (gl.canvas && container.contains(gl.canvas)) {
            container.removeChild(gl.canvas);
          }
          gl.getExtension('WEBGL_lose_context')?.loseContext();
        };
      }, [color, cursorBallColor, speed, enableMouseInteraction, hoverSmoothness, animationSize, ballCount, clumpFactor, cursorBallSize, enableTransparency]);

      return h('div', { ref: containerRef, className: `metaballs-container ${className}` });
    }

    // ============================================
    // VariableProximity Component
    // ============================================

    function useAnimationFrame(callback) {
      useEffect(() => {
        let frameId;
        const loop = () => {
          callback();
          frameId = requestAnimationFrame(loop);
        };
        frameId = requestAnimationFrame(loop);
        return () => cancelAnimationFrame(frameId);
      }, [callback]);
    }

    function useMousePositionRef(containerRef) {
      const positionRef = useRef({ x: 0, y: 0 });

      useEffect(() => {
        const updatePosition = (x, y) => {
          if (containerRef?.current) {
            const rect = containerRef.current.getBoundingClientRect();
            positionRef.current = { x: x - rect.left, y: y - rect.top };
          } else {
            positionRef.current = { x, y };
          }
        };

        const handleMouseMove = ev => updatePosition(ev.clientX, ev.clientY);
        const handleTouchMove = ev => {
          const touch = ev.touches[0];
          updatePosition(touch.clientX, touch.clientY);
        };

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('touchmove', handleTouchMove);
        return () => {
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('touchmove', handleTouchMove);
        };
      }, [containerRef]);

      return positionRef;
    }

    const VariableProximity = forwardRef((props, ref) => {
      const {
        label,
        fromFontVariationSettings = "'wght' 400",
        toFontVariationSettings = "'wght' 900",
        containerRef,
        radius = 150,
        falloff = 'linear',
        className = '',
        onClick,
        style,
        ...restProps
      } = props;

      const letterRefs = useRef([]);
      const interpolatedSettingsRef = useRef([]);
      const mousePositionRef = useMousePositionRef(containerRef);
      const lastPositionRef = useRef({ x: null, y: null });

      const parsedSettings = useMemo(() => {
        const parseSettings = settingsStr =>
          new Map(
            settingsStr
              .split(',')
              .map(s => s.trim())
              .map(s => {
                const [name, value] = s.split(' ');
                return [name.replace(/['"]/g, ''), parseFloat(value)];
              })
          );

        const fromSettings = parseSettings(fromFontVariationSettings);
        const toSettings = parseSettings(toFontVariationSettings);

        return Array.from(fromSettings.entries()).map(([axis, fromValue]) => ({
          axis,
          fromValue,
          toValue: toSettings.get(axis) ?? fromValue
        }));
      }, [fromFontVariationSettings, toFontVariationSettings]);

      const calculateDistance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

      const calculateFalloff = distance => {
        const norm = Math.min(Math.max(1 - distance / radius, 0), 1);
        switch (falloff) {
          case 'exponential':
            return norm ** 2;
          case 'gaussian':
            return Math.exp(-((distance / (radius / 2)) ** 2) / 2);
          case 'linear':
          default:
            return norm;
        }
      };

      useAnimationFrame(() => {
        if (!containerRef?.current) return;
        const containerRect = containerRef.current.getBoundingClientRect();
        const { x, y } = mousePositionRef.current;
        if (lastPositionRef.current.x === x && lastPositionRef.current.y === y) {
          return;
        }
        lastPositionRef.current = { x, y };

        letterRefs.current.forEach((letterRef, index) => {
          if (!letterRef) return;

          const rect = letterRef.getBoundingClientRect();
          const letterCenterX = rect.left + rect.width / 2 - containerRect.left;
          const letterCenterY = rect.top + rect.height / 2 - containerRect.top;

          const distance = calculateDistance(
            mousePositionRef.current.x,
            mousePositionRef.current.y,
            letterCenterX,
            letterCenterY
          );

          if (distance >= radius) {
            letterRef.style.fontVariationSettings = fromFontVariationSettings;
            return;
          }

          const falloffValue = calculateFalloff(distance);
          const newSettings = parsedSettings
            .map(({ axis, fromValue, toValue }) => {
              const interpolatedValue = fromValue + (toValue - fromValue) * falloffValue;
              return `'${axis}' ${interpolatedValue}`;
            })
            .join(', ');

          interpolatedSettingsRef.current[index] = newSettings;
          letterRef.style.fontVariationSettings = newSettings;
        });
      });

      const words = label.split(' ');
      let letterIndex = 0;

      return h(
        'span',
        {
          ref,
          className: `${className} variable-proximity`,
          onClick,
          style: { display: 'inline', ...style },
          ...restProps
        },
        words.map((word, wordIndex) =>
          h(
            'span',
            { key: wordIndex, style: { display: 'inline-block', whiteSpace: 'nowrap' } },
            word.split('').map(letter => {
              const currentLetterIndex = letterIndex++;
              return h(
                motion.span,
                {
                  key: currentLetterIndex,
                  ref: el => {
                    letterRefs.current[currentLetterIndex] = el;
                  },
                  style: {
                    display: 'inline-block',
                    fontVariationSettings: interpolatedSettingsRef.current[currentLetterIndex]
                  },
                  'aria-hidden': true
                },
                letter
              );
            }),
            wordIndex < words.length - 1 && h('span', { style: { display: 'inline-block' } }, '\u00A0')
          )
        ),
        h('span', { className: 'sr-only' }, label)
      );
    });

    // ============================================
    // TrueFocus Component
    // ============================================

    function TrueFocus({
      sentence = 'True Focus',
      separator = ' ',
      manualMode = false,
      blurAmount = 5,
      borderColor = '#4c62ba',
      glowColor = 'rgba(76, 98, 186, 0.6)',
      animationDuration = 0.5,
      pauseBetweenAnimations = 1
    }) {
      const words = sentence.split(separator);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [lastActiveIndex, setLastActiveIndex] = useState(null);
      const containerRef = useRef(null);
      const wordRefs = useRef([]);
      const [focusRect, setFocusRect] = useState({ x: 0, y: 0, width: 0, height: 0 });

      useEffect(() => {
        if (!manualMode) {
          const interval = setInterval(
            () => {
              setCurrentIndex(prev => (prev + 1) % words.length);
            },
            (animationDuration + pauseBetweenAnimations) * 1000
          );

          return () => clearInterval(interval);
        }
      }, [manualMode, animationDuration, pauseBetweenAnimations, words.length]);

      useEffect(() => {
        if (currentIndex === null || currentIndex === -1) return;

        if (!wordRefs.current[currentIndex] || !containerRef.current) return;

        const parentRect = containerRef.current.getBoundingClientRect();
        const activeRect = wordRefs.current[currentIndex].getBoundingClientRect();

        setFocusRect({
          x: activeRect.left - parentRect.left,
          y: activeRect.top - parentRect.top,
          width: activeRect.width,
          height: activeRect.height
        });
      }, [currentIndex, words.length]);

      const handleMouseEnter = index => {
        if (manualMode) {
          setLastActiveIndex(index);
          setCurrentIndex(index);
        }
      };

      const handleMouseLeave = () => {
        if (manualMode) {
          setCurrentIndex(lastActiveIndex);
        }
      };

      return h(
        'div',
        { className: 'focus-container', ref: containerRef },
        words.map((word, index) => {
          const isActive = index === currentIndex;
          return h(
            'span',
            {
              key: index,
              ref: el => (wordRefs.current[index] = el),
              className: `focus-word ${manualMode ? 'manual' : ''} ${isActive && !manualMode ? 'active' : ''}`,
              style: {
                filter: manualMode
                  ? isActive
                    ? 'blur(0px)'
                    : `blur(${blurAmount}px)`
                  : isActive
                    ? 'blur(0px)'
                    : `blur(${blurAmount}px)`,
                '--border-color': borderColor,
                '--glow-color': glowColor,
                transition: `filter ${animationDuration}s ease`
              },
              onMouseEnter: () => handleMouseEnter(index),
              onMouseLeave: handleMouseLeave
            },
            word
          );
        }),
        h(
          motion.div,
          {
            className: 'focus-frame',
            animate: {
              x: focusRect.x,
              y: focusRect.y,
              width: focusRect.width,
              height: focusRect.height,
              opacity: currentIndex >= 0 ? 1 : 0
            },
            transition: {
              duration: animationDuration
            },
            style: {
              '--border-color': borderColor,
              '--glow-color': glowColor
            }
          },
          h('span', { className: 'corner top-left' }),
          h('span', { className: 'corner top-right' }),
          h('span', { className: 'corner bottom-left' }),
          h('span', { className: 'corner bottom-right' })
        )
      );
    }

    // ============================================
    // BilingualTrueFocus Component
    // ============================================

    function BilingualTrueFocus({
      items = [],
      manualMode = true,
      blurAmount = 8,
      borderColor = '#4c62ba',
      glowColor = 'rgba(76, 98, 186, 0.6)',
      animationDuration = 0.6
    }) {
      const [currentIndex, setCurrentIndex] = useState(0);
      const [lastActiveIndex, setLastActiveIndex] = useState(null);
      const containerRef = useRef(null);
      const wordRefs = useRef([]);
      const [focusRect, setFocusRect] = useState({ x: 0, y: 0, width: 0, height: 0 });

      useEffect(() => {
        if (currentIndex === null || currentIndex === -1) return;

        if (!wordRefs.current[currentIndex] || !containerRef.current) return;

        const parentRect = containerRef.current.getBoundingClientRect();
        const activeRect = wordRefs.current[currentIndex].getBoundingClientRect();

        setFocusRect({
          x: activeRect.left - parentRect.left,
          y: activeRect.top - parentRect.top,
          width: activeRect.width,
          height: activeRect.height
        });
      }, [currentIndex]);

      const handleMouseEnter = index => {
        if (manualMode) {
          setLastActiveIndex(index);
          setCurrentIndex(index);
        }
      };

      const handleMouseLeave = () => {
        if (manualMode) {
          setCurrentIndex(lastActiveIndex);
        }
      };

      return h(
        'div',
        { className: 'focus-container', ref: containerRef },
        items.map((item, index) => {
          const isActive = index === currentIndex;
          return h(
            'span',
            {
              key: index,
              ref: el => (wordRefs.current[index] = el),
              className: `focus-word ${manualMode ? 'manual' : ''} ${isActive && !manualMode ? 'active' : ''}`,
              style: {
                filter: isActive ? 'blur(0px)' : `blur(${blurAmount}px)`,
                transition: `filter ${animationDuration}s ease`
              },
              onMouseEnter: () => handleMouseEnter(index),
              onMouseLeave: handleMouseLeave
            },
            h('span', { className: 'english' }, item.english),
            h('span', { className: 'persian' }, item.persian)
          );
        }),
        h(
          motion.div,
          {
            className: 'focus-frame',
            animate: {
              x: focusRect.x,
              y: focusRect.y,
              width: focusRect.width,
              height: focusRect.height,
              opacity: currentIndex >= 0 ? 1 : 0
            },
            transition: {
              duration: animationDuration
            },
            style: {
              '--border-color': borderColor,
              '--glow-color': glowColor
            }
          },
          h('span', { className: 'corner top-left' }),
          h('span', { className: 'corner top-right' }),
          h('span', { className: 'corner bottom-left' }),
          h('span', { className: 'corner bottom-right' })
        )
      );
    }


    // ============================================
    // MacOS Window Component
    // ============================================

    function MacOSWindow({ title = 'Window', children, className = '', isFullscreen = false }) {
      return h(
        motion.div,
        {
          className: `macos-window ${className} ${isFullscreen ? 'fullscreen' : ''}`,
          initial: { scale: 0.9, opacity: 0 },
          animate: {
            scale: 1,
            opacity: 1
          },
          transition: { duration: 0.4, type: 'spring', damping: 20 }
        },
        // Title Bar
        h(
          'div',
          { className: 'macos-titlebar' },
          // Traffic Lights
          h(
            'div',
            { className: 'macos-traffic-lights' },
            h('div', { className: 'macos-traffic-light close' }),
            h('div', { className: 'macos-traffic-light minimize' }),
            h('div', { className: 'macos-traffic-light maximize' })
          ),
          // Window Title
          h('div', { className: 'macos-window-title' }, title)
        ),
        // Content
        h('div', { className: 'macos-window-content' }, children)
      );
    }

    // ============================================
    // Slide Components
    // ============================================

    function Slide1() {
      const containerRef = useRef(null);

      return h(
        'div',
        { className: 'slide-hero', ref: containerRef },
        h(
          'div',
          { className: 'hero-content' },
          h(
            'div',
            { className: 'ozone-logo' },
            h(VariableProximity, {
              label: 'OZONE',
              fromFontVariationSettings: "'wght' 400",
              toFontVariationSettings: "'wght' 900",
              containerRef: containerRef,
              radius: 200,
              falloff: 'exponential'
            })
          ),
          h('div', { className: 'ozone-tagline' }, 'The Mutual Language of Design and Production')
        )
      );
    }

    function Slide2({ onSystemClick }) {
      const philosophyItems = [
        {
          english: h(React.Fragment, null, 'One ', h('em', null, 'System')),
          persian: 'یک سیستم'
        },
        {
          english: h(React.Fragment, null, 'One ', h('em', null, 'Tool')),
          persian: 'یک ابزار'
        },
        {
          english: h(React.Fragment, null, 'One ', h('em', null, 'Design')),
          persian: 'یک طرح'
        }
      ];

      return h(
        'div',
        { className: 'slide-philosophy' },
        h(
          'div',
          { className: 'philosophy-content' },
          h('div', { className: 'philosophy-title' }, 'The Philosophy'),
          h(
            'div',
            {
              className: 'philosophy-focus',
              onClick: (e) => {
                // Check if "One System" was clicked (index 0)
                const target = e.target.closest('.focus-word');
                if (target && target === target.parentElement.children[0]) {
                  onSystemClick();
                }
              }
            },
            h(BilingualTrueFocus, {
              items: philosophyItems,
              manualMode: true,
              blurAmount: 8,
              borderColor: '#4c62ba',
              glowColor: 'rgba(76, 98, 186, 0.6)',
              animationDuration: 0.6
            })
          )
        )
      );
    }

    function Slide3() {
      const [isFullscreen, setIsFullscreen] = useState(false);
      const slideRef = useRef(null);
      const isTransitioningRef = useRef(false);

      useEffect(() => {
        let wheelTimeout = null;
        let lastScrollTime = 0;

        const handleWheel = (e) => {
          const now = Date.now();

          // Check if we're on the active slide
          if (!slideRef.current || !slideRef.current.closest('.slide.active')) {
            return;
          }

          // Prevent rapid toggling - require at least 100ms between scroll events
          if (now - lastScrollTime < 100) {
            return;
          }

          // If already transitioning, ignore
          if (isTransitioningRef.current) {
            return;
          }

          const scrollThreshold = 30; // Reduced threshold for better responsiveness
          const deltaY = e.deltaY;

          console.log('Scroll detected:', { deltaY, isFullscreen, isTransitioning: isTransitioningRef.current });

          if (Math.abs(deltaY) > scrollThreshold) {
            if (deltaY > 0 && !isFullscreen) {
              // Scrolling down - go fullscreen
              console.log('Going fullscreen');
              lastScrollTime = now;
              isTransitioningRef.current = true;
              setIsFullscreen(true);

              // Reset transition lock after animation completes
              if (wheelTimeout) clearTimeout(wheelTimeout);
              wheelTimeout = setTimeout(() => {
                isTransitioningRef.current = false;
                console.log('Transition complete - fullscreen');
              }, 1000);
            } else if (deltaY < 0 && isFullscreen) {
              // Scrolling up - exit fullscreen
              console.log('Exiting fullscreen');
              lastScrollTime = now;
              isTransitioningRef.current = true;
              setIsFullscreen(false);

              // Reset transition lock after animation completes
              if (wheelTimeout) clearTimeout(wheelTimeout);
              wheelTimeout = setTimeout(() => {
                isTransitioningRef.current = false;
                console.log('Transition complete - windowed');
              }, 1000);
            }
          }
        };

        const handleKeyDown = (e) => {
          if (slideRef.current && slideRef.current.closest('.slide.active')) {
            if (e.key === 'f' || e.key === 'F') {
              // Toggle fullscreen with 'F' key
              setIsFullscreen(prev => !prev);
            } else if (e.key === 'Escape' && isFullscreen) {
              // Exit fullscreen with Escape
              setIsFullscreen(false);
            }
          }
        };

        window.addEventListener('wheel', handleWheel, { passive: true });
        window.addEventListener('keydown', handleKeyDown);

        return () => {
          window.removeEventListener('wheel', handleWheel);
          window.removeEventListener('keydown', handleKeyDown);
          if (wheelTimeout) {
            clearTimeout(wheelTimeout);
          }
        };
      }, [isFullscreen]);

      return h(
        'div',
        {
          ref: slideRef,
          className: `slide-one-system ${isFullscreen ? 'fullscreen' : ''}`
        },
        // Header Section
        h(
          'div',
          { className: 'one-system-header' },
          h('h1', { className: 'one-system-title' }, 'One System'),
          h('p', { className: 'one-system-subtitle' }, 'یک سیستم یکپارچه برای طراحی و تولید')
        ),
        // macOS Window with Embedded Dashboard
        h(
          'div',
          { className: 'one-system-content' },
          h(
            MacOSWindow,
            { title: 'OZONE Manager Dashboard', isFullscreen },
            h('iframe', {
              src: './Presentation/managers-dashboard/manager-dashboard.html',
              title: 'OZONE Manager Dashboard',
              style: { background: 'white' }
            })
          )
        ),
        // Scroll Indicator (only visible when not fullscreen)
        !isFullscreen && h(
          'div',
          { className: 'scroll-indicator' },
          h('div', { className: 'scroll-indicator-text' }, 'Scroll down for fullscreen'),
          h('div', { className: 'scroll-indicator-icon' })
        ),
        h('div', { className: 'back-hint' }, isFullscreen ? 'Press ESC or scroll up to exit fullscreen' : 'Press ← to go back')
      );
    }

    // ============================================
    // Main App
    // ============================================

    function App() {
      const [currentSlide, setCurrentSlide] = useState(0);
      const totalSlides = 3;

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
            setCurrentSlide(prev => Math.min(prev + 1, totalSlides - 1));
          } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
            setCurrentSlide(prev => Math.max(prev - 1, 0));
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      const handleSystemClick = () => {
        setCurrentSlide(2); // Navigate to slide 3 (One System)
      };

      return h(
        React.Fragment,
        null,
        // Global MetaBalls Background
        h(
          'div',
          { className: 'global-metaballs-background' },
          h(MetaBalls, {
            color: '#4c62ba',
            cursorBallColor: '#6a7fc1',
            cursorBallSize: 2,
            ballCount: 12,
            animationSize: 40,
            enableMouseInteraction: true,
            enableTransparency: true,
            hoverSmoothness: 0.05,
            clumpFactor: 1.2,
            speed: 0.2
          })
        ),
        // Presentation Container
        h(
          'div',
          { className: 'presentation-container' },
          // Slide 1
          h(
            'div',
            { className: `slide ${currentSlide === 0 ? 'active' : ''}` },
            h(Slide1)
          ),
          // Slide 2
          h(
            'div',
            { className: `slide ${currentSlide === 1 ? 'active' : ''}` },
            h(Slide2, { onSystemClick: handleSystemClick })
          ),
          // Slide 3
          h(
            'div',
            { className: `slide ${currentSlide === 2 ? 'active' : ''}` },
            h(Slide3)
          ),
          // Navigation Indicators
          h(
            'div',
            { className: 'slide-indicators' },
            Array.from({ length: totalSlides }).map((_, index) =>
              h('div', {
                key: index,
                className: `indicator ${currentSlide === index ? 'active' : ''}`,
                onClick: () => setCurrentSlide(index),
                title: `Slide ${index + 1}`
              })
            )
          )
        )
      );
    }

    // Render
    const root = createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>
